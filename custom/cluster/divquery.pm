# $Id: divquery.pm,v 1.4 2006/07/31 23:48:53 publicwhip Exp $
# This extracts a distance metric for a set of divisions, and is able to write
# it out in a format for loading into GNU Ooctave (or MatLab)

# The Public Whip, Copyright (C) 2003 Francis Irving and Julian Todd
# This is free software, and you are welcome to redistribute it under
# certain conditions.  However, it comes with ABSOLUTELY NO WARRANTY.
# For details see the file LICENSE.html in the top level of the source.

package divquery;
use strict;

sub get_div_ixs
{
    my $dbh = shift; 
    my $where = shift;

    my $sth = PublicWhip::DB::query($dbh, "select division_id from pw_division where 1 = 1 $where order by division_date desc");
    my @div_ixs;
    while (my @data = $sth->fetchrow_array())
    {
        push @div_ixs, $data[0];
    }
    return \@div_ixs;
}

# TODO: Update
sub octave_writer
{
    my $fh = shift;
    my $dbh = shift;
    my $div_ixs = shift;
    my $metricD = shift;

    use POSIX qw(strftime);
    my $now_string = strftime "%a %b %e %H:%M:%S %Y", localtime;
    print $fh "# Autogenerated by divquery::octave_writer from The Public Whip project on $now_string\n\n";

    # Print it all out
    for my $div_1 (@$div_ixs)
    {
        my $sthmp = PublicWhip::DB::query($dbh, "select division_name, division_date, division_number from pw_division where division_id=?", $div_1);
        die "Wrong number of rows back" if $sthmp->rows != 1;
        my @data = $sthmp->fetchrow_array();
        my ($division_name, $division_date, $division_number) = @data; 
        $division_name =~ s/&#8212;/-/g;
        $division_name =~ s/"/'/g;
        $division_date =~ m/^(\d\d\d\d)/;
        my $division_year = $1;

        print $fh "na" . $div_1 . " = \"" . $division_name . "\";\n";
        print $fh "pa" . $div_1 . " = \"" . $division_date. " #" . $division_number . "\";\n";
        print $fh "r" . $div_1 . " = [";
        for my $div_2 (@$div_ixs)
        {
            print $fh "," if ($div_2 != $$div_ixs[0]);
            if ($div_1 <= $div_2)
            {
                if (!defined($$metricD[$div_1][$div_2])) {
                    print $fh "-1"; # case where divisions don't overlap in time
                } else {
                    print $fh $$metricD[$div_1][$div_2];
                }
            }
            else
            {
                if (!defined($$metricD[$div_2][$div_1])) {
                    print $fh "-1"; # case where divisions don't overlap in time
                } else {
                    print $fh $$metricD[$div_2][$div_1];
                }
            }
        }
        print $fh "];\n";
    }

    print $fh "D=[\n";
    foreach my $div_ix (@$div_ixs)
    {
        print $fh "r" . $div_ix . ";";
    }
    print $fh "];\n";

    print $fh "ns=[\n";
    for my $div_ix (@$div_ixs)
    {
        print $fh "na" . $div_ix . ";";
    }
    print $fh "];\n";

    print $fh "ps=[\n";
    for my $div_ix (@$div_ixs)
    {
        print $fh "pa" . $div_ix . ";";
    }
    print $fh "];\n";
}

1;
