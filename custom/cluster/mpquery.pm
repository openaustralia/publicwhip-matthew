# $Id: mpquery.pm,v 1.7 2006/07/31 23:35:14 publicwhip Exp $
# This extracts a vote distance metric for a set of MPs, and is able to
# write it out in a format for loading into GNU Ooctave (or MatLab)

# The Public Whip, Copyright (C) 2003 Francis Irving and Julian Todd
# This is free software, and you are welcome to redistribute it under
# certain conditions.  However, it comes with ABSOLUTELY NO WARRANTY.
# For details see the file LICENSE.html in the top level of the source.

package mpquery;
use strict;

sub get_mp_ixs
{
    my $dbh = shift; 
    my $where = shift;
    my $limit = shift;
    my $order = shift;

    my $sth = PublicWhip::DB::query($dbh, "select pw_mp.mp_id from pw_mp, pw_cache_mpinfo where
        pw_mp.mp_id = pw_cache_mpinfo.mp_id and $where 
        order by $order $limit");
    my @mp_ixs;
    while (my @data = $sth->fetchrow_array())
    {
        push @mp_ixs, $data[0];
    }
    return \@mp_ixs;
}

sub vote_metric_from_db
{
    my $dbh = shift;
    my $mp_ixs = shift;

    my $limit1 = " (mp_id1 = " . join(" or mp_id1 = ", @$mp_ixs) . ")";
    my $limit2 = " (mp_id2 = " . join(" or mp_id2 = ", @$mp_ixs) . ")";
    my $sth = PublicWhip::DB::query($dbh, "select mp_id1, mp_id2, distance_a from pw_cache_realreal_distance
        where $limit1 and $limit2 and mp_id1 <= mp_id2");

    my @metricD;
    while (my @data = $sth->fetchrow_array())
    {
        my ($mp_1, $mp_2, $distance) = @data;
        
        die "half triangle only should be coming out" if $mp_1 > $mp_2;

        # -1 is case where there is no vote overlap
        if ($distance != -1)
        {
            die "distance out of range 0 to 1" if $distance < 0.0 or $distance > 1.0;
            $metricD[$mp_1][$mp_2] = $distance;
        }
        elsif ($mp_1 == $mp_2)
        {
            $metricD[$mp_1][$mp_2] = 0; # No-voters, like Gerry Adams need this clause
        }
        else
        {
            $metricD[$mp_1][$mp_2] = 1;
        }
    }

    return \@metricD;
}

sub octave_writer
{
    my $fh = shift;
    my $dbh = shift;
    my $mp_ixs = shift;
    my $metricD = shift;

    use POSIX qw(strftime);
    my $now_string = strftime "%a %b %e %H:%M:%S %Y", localtime;
    print $fh "# Autogenerated by mpquery::octave_writer from The Public Whip project on $now_string\n\n";

    # Print it all out
    for my $mp_1 (@$mp_ixs)
    {
        my $sthmp = PublicWhip::DB::query($dbh, "select last_name, first_name, party, house, title from pw_mp where mp_id=?", $mp_1);
        die "Wrong number of rows back" if $sthmp->rows != 1;
        my @data = $sthmp->fetchrow_array();
        my ($lastname, $firstname, $party, $house, $title) = @data; 

        if ($house eq "commons") {
            print $fh "na" . $mp_1 . " = \"" . $lastname . ", " . $firstname . "\";\n";
        } else {
            print $fh "na" . $mp_1 . " = \"" . $title . " " . $firstname . " " . $lastname . "\";\n";
        }
        print $fh "pa" . $mp_1 . " = \"" . $party . "\";\n";
        print $fh "r" . $mp_1 . " = [";
        for my $mp_2 (@$mp_ixs)
        {
            print $fh "," if ($mp_2 != $$mp_ixs[0]);
            if ($mp_1 <= $mp_2)
            {
                if (!defined($$metricD[$mp_1][$mp_2])) {
                    print $fh "-1"; # case where members don't overlap in time
                } else {
                    print $fh $$metricD[$mp_1][$mp_2];
                }
            }
            else
            {
                if (!defined($$metricD[$mp_2][$mp_1])) {
                    print $fh "-1"; # case where members don't overlap in time
                } else {
                    print $fh $$metricD[$mp_2][$mp_1];
                }
            }
        }
        print $fh "];\n";
    }

    print $fh "D=[\n";
    foreach my $mp_ix (@$mp_ixs)
    {
        print $fh "r" . $mp_ix . ";";
    }
    print $fh "];\n";

    print $fh "ns=[\n";
    for my $mp_ix (@$mp_ixs)
    {
        print $fh "na" . $mp_ix . ";";
    }
    print $fh "];\n";

    print $fh "ps=[\n";
    for my $mp_ix (@$mp_ixs)
    {
        print $fh "pa" . $mp_ix . ";";
    }
    print $fh "];\n";
}

1;
